import{_ as n,p as s,q as a,a1 as e}from"./framework-5866ffd3.js";const t={},o=e(`<h1 id="webassembly" tabindex="-1"><a class="header-anchor" href="#webassembly" aria-hidden="true">#</a> WebAssembly</h1><h2 id="introduction" tabindex="-1"><a class="header-anchor" href="#introduction" aria-hidden="true">#</a> Introduction</h2><p><strong>WebAssembly</strong> (often abbreviated as <strong>wasm</strong>) is a low-level bytecode format designed to be executed in a web browser. It is a binary instruction format for a stack-based virtual machine, which is designed to run in web browsers alongside JavaScript. WebAssembly code can be written in languages other than JavaScript, such as C++, Rust, or Go, and it is designed to be faster and more efficient than JavaScript.</p><p><strong>WebAssembly</strong> is designed to be a portable and secure platform that can be used to execute code across a wide range of devices and operating systems. It is designed to be compatible with a wide range of programming languages and compilers, making it easy to integrate with existing codebases. WebAssembly can be used for a variety of purposes, including video and audio processing, gaming, and scientific simulations.</p><p><strong>WebAssembly</strong> has been developed by a consortium of major browser vendors, including Mozilla, Google, Apple, and Microsoft, and it is now supported by all major web browsers, including Chrome, Firefox, Safari, and Edge.</p><p>Here&#39;s a simple &quot;Hello, World!&quot; program written in WebAssembly text format:</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token punctuation">(</span>module
  <span class="token punctuation">(</span>func <span class="token variable">$add</span> <span class="token punctuation">(</span>param <span class="token variable">$a</span> i32<span class="token punctuation">)</span> <span class="token punctuation">(</span>param <span class="token variable">$b</span> i32<span class="token punctuation">)</span> <span class="token punctuation">(</span>result i32<span class="token punctuation">)</span> <span class="token punctuation">(</span>export <span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span>
    <span class="token punctuation">(</span>i32.add
      <span class="token punctuation">(</span>get_local <span class="token variable">$a</span><span class="token punctuation">)</span>
      <span class="token punctuation">(</span>get_local <span class="token variable">$b</span><span class="token punctuation">)</span>
    <span class="token punctuation">)</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>This program exports a function called &quot;hello&quot; that adds together the integers 0 and 12, and returns the result as a 32-bit integer.</p><p>To compile this code into a WebAssembly binary, you can use a tool like the wat2wasm command-line tool that comes with the WebAssembly Binary Toolkit (WABT):</p><div class="language-bash" data-ext="sh"><pre class="language-bash"><code>wat2wasm hello.wat <span class="token parameter variable">-o</span> hello.wasm
</code></pre></div><p>This will create a file called hello.wasm that contains the compiled WebAssembly code.</p><p>To run the compiled code in a browser environment, you can use JavaScript to load the WebAssembly module and call the exported function:</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>const wasmModule <span class="token operator">=</span> new WebAssembly.Module<span class="token punctuation">(</span>
  await fetch<span class="token punctuation">(</span><span class="token string">&#39;hello.wasm&#39;</span><span class="token punctuation">)</span>.then<span class="token punctuation">(</span>
    response <span class="token operator">=</span><span class="token operator">&gt;</span> response.arrayBuffer<span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
const wasmInstance <span class="token operator">=</span> new WebAssembly.Instance<span class="token punctuation">(</span>wasmModule<span class="token punctuation">)</span><span class="token punctuation">;</span>
const result <span class="token operator">=</span> wasmInstance.exports.hello<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console.log<span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>  // output: <span class="token number">12</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>This JavaScript code loads the compiled hello.wasm module using the Fetch API, creates an instance of the module, and calls the exported hello function. The resulting value of 12 is logged to the console.</p><h2 id="audio-video-with-wasm" tabindex="-1"><a class="header-anchor" href="#audio-video-with-wasm" aria-hidden="true">#</a> Audio &amp; Video with WASM</h2><p>To work with audio and video in WebAssembly, developers can use libraries such as FFmpeg, WebCodecs, and Web Audio API. FFmpeg is a popular open-source multimedia framework that can be compiled to WebAssembly using Emscripten, a toolchain for compiling C and C++ code to WASM. WebCodecs is a new API that provides low-level access to video encoding and decoding capabilities in modern web browsers. Web Audio API, on the other hand, allows developers to create and manipulate audio streams directly in the browser.</p><p>With these tools, developers can create powerful and efficient multimedia applications that can run in web browsers without the need for additional plugins or software. However, it&#39;s important to note that working with audio and video in WebAssembly can be complex and requires a strong understanding of both multimedia programming and the WebAssembly environment.</p><h2 id="ffmpeg-with-wasm" tabindex="-1"><a class="header-anchor" href="#ffmpeg-with-wasm" aria-hidden="true">#</a> FFmpeg with WASM</h2><p>FFmpeg is a popular multimedia framework that is widely used for video and audio processing, encoding, decoding, and transcoding. With WebAssembly, developers can compile FFmpeg to run in web browsers and create multimedia applications that can work on the client-side without relying on external servers.</p><p>To use FFmpeg with WebAssembly, developers can compile the FFmpeg codebase to WASM using Emscripten, a toolchain for compiling C and C++ code to WebAssembly. Emscripten converts C/C++ code to LLVM bitcode, which can then be compiled to WebAssembly using the LLVM backend. The resulting WebAssembly module can then be loaded into a web page and used to process multimedia data.</p><p>One important consideration when using FFmpeg with WebAssembly is the size of the resulting WebAssembly module. The FFmpeg codebase is quite large, and even with optimizations, the resulting module can be several megabytes in size. This can impact page load times and require additional network bandwidth to download the module.</p><p>Despite these challenges, using FFmpeg with WebAssembly can provide significant performance benefits for multimedia applications. WebAssembly allows developers to run high-performance multimedia processing code in a secure, sandboxed environment, without relying on external servers or plugins. This can enable developers to create more powerful and flexible multimedia applications that can work seamlessly across a variety of platforms and devices.</p><h4 id="compile-ffmpeg-by-using-webassembly" tabindex="-1"><a class="header-anchor" href="#compile-ffmpeg-by-using-webassembly" aria-hidden="true">#</a> Compile FFmpeg by using WebAssembly</h4><ol><li>Download the latest FFmpeg source code</li></ol><div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token function">git</span> clone https://git.ffmpeg.org/ffmpeg.git ffmpeg

// switch to the latest version
<span class="token function">git</span> branch <span class="token parameter variable">-r</span>
<span class="token function">git</span> checkout origin/release/5.1
</code></pre></div><ol start="2"><li>Understand the principle of cross compilation</li></ol><p>Specify compilation tools for FFmpeg in order to run FFmpeg in the browser:</p><ul><li>C language compilation tool <code>--cc=&quot;emcc&quot;</code></li><li>C++ compilation tool <code>--cxx=&quot;em++&quot;</code></li><li>Create a static library tool <code>--ar=&quot;emar&quot;</code></li></ul><p>Specify output target for FFmpeg:</p><ul><li>Use cross compilation <code>--enable-cross-compile</code></li><li>Specify the operating system to run <code>--target-os=none</code></li><li>Specify CPU architecture <code>--arch=x86_32</code></li><li>Specify CPU model <code>--cpu=generic</code></li></ul><ol start="3"><li>Crop FFmpeg</li></ol><ul><li>Turn off some big modules</li></ul><div class="language-bash" data-ext="sh"><pre class="language-bash"><code>--disable-avformat --disable-avdevice --disable-avfilter --disable-swresample
</code></pre></div><ul><li>Turn off all codecs, hardware acceleration, multiplexers, etc</li></ul><div class="language-bash" data-ext="sh"><pre class="language-bash"><code>--disable-programs --disable-debug --disable-doc
</code></pre></div><div class="language-bash" data-ext="sh"><pre class="language-bash"><code>--disable-everything
</code></pre></div><ul><li>Turn on modules only we need</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>--enable-decoder<span class="token operator">=</span>hevc --enable-parser<span class="token operator">=</span>hevc  // H265
--enable-decoder<span class="token operator">=</span>h264 --enable-parser<span class="token operator">=</span>h264  // H264
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>Write script</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">mkdir</span> /home/wasm/decoder
<span class="token builtin class-name">cd</span> /home/wasm/decoder
<span class="token function">vi</span> buildffmpeg.sh
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token shebang important">#!/bin/bash</span>

<span class="token function">rm</span> <span class="token parameter variable">-rf</span> ./ffmpeg
<span class="token function">mkdir</span> <span class="token parameter variable">-p</span> ./ffmpeg
<span class="token function">chmod</span> <span class="token parameter variable">-R</span> <span class="token number">777</span> ./ffmpeg

<span class="token builtin class-name">cd</span> <span class="token punctuation">..</span>/ffmpeg
<span class="token function">make</span> clean

emconfigure ./configure <span class="token parameter variable">--cc</span><span class="token operator">=</span><span class="token string">&quot;emcc&quot;</span> <span class="token parameter variable">--cxx</span><span class="token operator">=</span><span class="token string">&quot;em++&quot;</span> <span class="token parameter variable">--ar</span><span class="token operator">=</span><span class="token string">&quot;emar&quot;</span> <span class="token parameter variable">--nm</span><span class="token operator">=</span><span class="token string">&quot;emnm&quot;</span> <span class="token parameter variable">--prefix</span><span class="token operator">=</span>/home/wasm/decoder/ffmpeg <span class="token punctuation">\\</span>
                        --enable-cross-compile --target-os<span class="token operator">=</span>none <span class="token parameter variable">--arch</span><span class="token operator">=</span>x86_32 <span class="token parameter variable">--cpu</span><span class="token operator">=</span>generic <span class="token punctuation">\\</span>
                        --disable-avformat --disable-avdevice --disable-swresample --disable-avfilter --disable-postproc <span class="token punctuation">\\</span>
                        --disable-programs --disable-debug --disable-doc <span class="token punctuation">\\</span>
                        --disable-everything --disable-asm <span class="token punctuation">\\</span>
                        --enable-decoder<span class="token operator">=</span>hevc --enable-parser<span class="token operator">=</span>hevc <span class="token punctuation">\\</span>
                        --enable-decoder<span class="token operator">=</span>h264 --enable-parser<span class="token operator">=</span>h264 <span class="token punctuation">\\</span>
                        --enable-gpl --enable-version3
<span class="token function">make</span>
<span class="token function">make</span> <span class="token function">install</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-bash" data-ext="sh"><pre class="language-bash"><code>./buildffmpeg.sh 
</code></pre></div><h2 id="ffmpeg-command" tabindex="-1"><a class="header-anchor" href="#ffmpeg-command" aria-hidden="true">#</a> FFmpeg Command</h2><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>ffmpeg <span class="token parameter variable">-i</span> demo.mp4 <span class="token parameter variable">-start_number</span> <span class="token number">0</span> <span class="token parameter variable">-hls_time</span> <span class="token number">10</span> <span class="token parameter variable">-hls_list_size</span> <span class="token number">0</span> <span class="token parameter variable">-hls_segment_filename</span> wasm%03d.ts index.m3u8
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="emcc-hello-c-g-o-hello-html" tabindex="-1"><a class="header-anchor" href="#emcc-hello-c-g-o-hello-html" aria-hidden="true">#</a> EMCC hello.c -g -o hello.html</h2><div class="language-bash" data-ext="sh"><pre class="language-bash"><code>emcc hello.c <span class="token parameter variable">-g</span> <span class="token parameter variable">-o</span> hello.html
</code></pre></div><p>The command &quot;emcc hello.c -g -o hello.html&quot; will compile the C file &quot;hello.c&quot; to a web page called &quot;hello.html&quot; using Emscripten.</p><p>The &quot;-g&quot; option tells Emscripten to generate debugging information, which can be useful for debugging the compiled code. The &quot;-o&quot; option specifies the output file name.</p><p>When you run this command, Emscripten will generate a JavaScript file and a WebAssembly binary file, along with the HTML file. The JavaScript file will contain the compiled code and the WebAssembly binary file will contain the compiled machine code.</p><p>You can then open the &quot;hello.html&quot; file in a web browser to see the compiled code in action. The web page will contain a script tag that loads the generated JavaScript file, which in turn loads and executes the WebAssembly binary file. The output of the program should be visible in the web browser&#39;s console.</p><h4 id="implementation-process" tabindex="-1"><a class="header-anchor" href="#implementation-process" aria-hidden="true">#</a> Implementation process</h4><p>When you open hello.html in your browser, the browser first loads the glue file hello.js. Then, it calls the createWasm(...) function in hello.js to load the WebAssembly module (hello.wasm). Next, it calls the callMain(...) method in hello.js to invoke the main function through the interface exposed by the WebAssembly instance.</p><p>In the main function, after executing the printf() method, WebAssembly will call the fd_write method (which was set when loading the WebAssembly module), and the string &quot;hello world!&quot; can be passed to the JavaScript layer through fd_write. Finally, the string will be output to the hello.html page through the out method in hello.js, and we can see the &quot;hello world!&quot; string in the browser.</p><h4 id="loading-webassembly-modules" tabindex="-1"><a class="header-anchor" href="#loading-webassembly-modules" aria-hidden="true">#</a> Loading WebAssembly Modules</h4><p>Before the browser can load a WebAssembly module, it needs to call the browser&#39;s fetch API to retrieve the WebAssembly module to be loaded from the WebServer. However, it should be noted that the WebAssembly binary code downloaded through fetch cannot be used directly.</p><p>Before using it, the <code>WebAssembly.compile()</code> method needs to be called to compile it and generate a Module, and then it needs to be instantiated through the <code>WebAssembly.instantiate()</code> method, which creates an object for it in memory.</p><p>With the knowledge above, let&#39;s take a look at the implementation code for loading <code>WebAssembly</code> next. The code is as follows:</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>var inst
var wasmpath <span class="token operator">=</span> <span class="token string">&quot;hello.wasm&quot;</span>
<span class="token punctuation">..</span>.
var asmLibArg <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">..</span>.
<span class="token punctuation">}</span>

<span class="token keyword">function</span> getInstance<span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  inst <span class="token operator">=</span> result.instance // get WebAssembly instance
<span class="token punctuation">}</span>

// load WebAssembly module
<span class="token keyword">function</span> <span class="token function-name function">createWasm</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  // <span class="token builtin class-name">set</span> callback <span class="token keyword">function</span>
  const importObj <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token string">&#39;env&#39;</span><span class="token builtin class-name">:</span> asmLibArg,
    <span class="token string">&#39;wasi_snapshot_preview1&#39;</span><span class="token builtin class-name">:</span> asmLibArg
  <span class="token punctuation">}</span>

  // get WebAssembly module <span class="token keyword">then</span> load
  fetch<span class="token punctuation">(</span>wasmpath<span class="token punctuation">)</span>
  .then<span class="token punctuation">(</span>response <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    WebAssembly.instantiateSteaming<span class="token punctuation">(</span>response, importObj<span class="token punctuation">)</span>
    .then<span class="token punctuation">(</span>getInstance, err<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>The most crucial part of the above code is the createWasm() function. This function first downloads the hello.wasm module from the WebServer using the fetch method. As this method uses the Promise asynchronous processing mechanism, when the download is successful, the arrow function in the then block will be executed. In this arrow function, the <code>WebAssembly.instantiateStream()</code> method is called to compile and instantiate the WebAssembly module. The <code>WebAssembly.instantiateStreaming()</code> method also uses the Promise asynchronous processing mechanism. After WebAssembly is instantiated, it calls the getInstance() method to obtain the instantiated object.&quot;</p><p>When calling the <code>WebAssembly.instantiateStreaming()</code> method, in addition to passing the response from the fetch as a parameter, an importObject object needs to be passed in as well. This object can contain some callback functions that are used to output the WebAssembly calculation results to the JavaScript layer.</p><p>Yes, with the above code, you can load a WebAssembly module into the browser!</p><h4 id="execute-process-of-main" tabindex="-1"><a class="header-anchor" href="#execute-process-of-main" aria-hidden="true">#</a> Execute Process of main()</h4><p>For the hello WebAssembly module mentioned above, its exported methods include the main method. The following code is the process of obtaining the main method:</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> Module <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token operator">...</span>
<span class="token keyword">function</span> <span class="token function">callMain</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> mainEntry <span class="token operator">=</span> Module<span class="token punctuation">[</span><span class="token string">&quot;_main&quot;</span><span class="token punctuation">]</span>  <span class="token comment">// get main function</span>
  <span class="token operator">...</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> ret <span class="token operator">=</span> <span class="token function">mainEntry</span><span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">)</span>  <span class="token comment">// call main function</span>
    <span class="token keyword">return</span> ret
  <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Exception:&quot;</span> <span class="token operator">+</span> e<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token parameter">result</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  inst <span class="token operator">=</span> result<span class="token punctuation">.</span>instance  <span class="token comment">// get WebAssembly instance</span>
  Module<span class="token punctuation">[</span><span class="token string">&quot;wasm&quot;</span><span class="token punctuation">]</span> <span class="token operator">=</span> inst<span class="token punctuation">.</span>exports  <span class="token comment">// get all exported functions in the instance</span>
  <span class="token function">callMain</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token operator">...</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>From the above code, we can see that after obtaining the WebAssembly instance in the getInstance() function, we can get its exported functions through the exports property of the instance object. For convenience, these functions are saved to Module[wasm] in the code. When calling the main() function, we need to first retrieve it from Module[wasm] using the &quot;_main&quot; keyword. After that, we can call the main() function in JavaScript to execute the WebAssembly code.</p><p>When calling the main() function, two parameters need to be passed, namely argc and argv. argc specifies the number of elements in the argv array, while argv is an array, and each element in the array is an address pointer pointing to a string.</p><p>It should be emphasized that, because the function parameter types in WebAssembly can only be integers and do not support string, array, struct, and other types, a tricky problem arises: How should the argv parameter in the main() function be passed?</p><p>Actually, this problem is easy to solve. We just need to treat the array as an address pointer. Therefore, we can directly assign the address of the allocated array to argv.</p><p>For WebAssembly, it provides a dedicated function for allocating memory space, called <code>stackAlloc()</code>. This function is one of the default exported functions of a WebAssembly module.</p><p>Let&#39;s take a look at how to use the <code>stackAlloc()</code> function to set values for the argv parameter in the glue code. The specific code is as follows:</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// Create stackAlloc package function</span>
<span class="token keyword">function</span> <span class="token function">createExportWarpper</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> fixedasm</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token operator">...</span>
    <span class="token keyword">return</span> wasm<span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span>  <span class="token comment">// call export function such as stackAlloc </span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">callMain</span><span class="token punctuation">(</span><span class="token parameter">result</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token operator">...</span>
  args <span class="token operator">=</span> args <span class="token operator">||</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token keyword">var</span> argc <span class="token operator">=</span> args<span class="token punctuation">.</span>length <span class="token operator">+</span> <span class="token number">1</span>  <span class="token comment">// generally speaking, args.length = 0</span>
  <span class="token keyword">var</span> argv <span class="token operator">=</span> <span class="token function">stackAlloc</span><span class="token punctuation">(</span><span class="token punctuation">(</span>argc <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">4</span><span class="token punctuation">)</span>  <span class="token comment">// alloc space address for argv</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">createWasm</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token operator">...</span>
<span class="token punctuation">}</span>

<span class="token function">createWasm</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// load WebAssembly</span>
<span class="token keyword">var</span> stackAlloc <span class="token operator">=</span> Module<span class="token punctuation">[</span><span class="token string">&quot;stackAlloc&quot;</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">createExportWarpper</span><span class="token punctuation">(</span><span class="token string">&quot;stackAlloc&quot;</span><span class="token punctuation">)</span>
<span class="token operator">...</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>As shown in the above code, when the main function is called from the JavaScript layer, values need to be set for argc and argv. The value of argc is very simple, it is set based on the args passed in. If args is empty, argc is 1, if there is one argument in args, argc is 2, and so on. The value of the argv parameter is directly set to the address of the array allocated by stackAlloc.</p><p>From the diagram, we can see that argv contains two elements, where the first element occupies 4 bytes and contains the address of the &quot;hello&quot; string, and the second element also occupies 4 bytes and contains the address of the &quot;aaa&quot; string. In fact, there is a third argument whose value is 0, but it is not shown in the diagram. In this way, the main() function of WebAssembly can obtain the values of the external parameters.</p><h2 id="wasm-modules-api" tabindex="-1"><a class="header-anchor" href="#wasm-modules-api" aria-hidden="true">#</a> WASM Modules API</h2><h4 id="webassembly-module" tabindex="-1"><a class="header-anchor" href="#webassembly-module" aria-hidden="true">#</a> WebAssembly.Module()</h4><p>WebAssembly.Module() is a constructor function in JavaScript that creates a new instance of a WebAssembly module. A WebAssembly module is a compiled program that can be executed in a browser or other compatible environment using the WebAssembly API.</p><p>To create a new WebAssembly module, you can use the WebAssembly.Module() constructor and pass in a compiled WebAssembly binary data as a parameter. Here is an example:</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> wasmCode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Uint8Array</span><span class="token punctuation">(</span><span class="token punctuation">[</span> <span class="token comment">/* compiled wasm binary data */</span> <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> wasmModule <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WebAssembly<span class="token punctuation">.</span>Module</span><span class="token punctuation">(</span>wasmCode<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>In this example, we first create a Uint8Array instance that contains the compiled WebAssembly binary data. Then, we pass the Uint8Array instance to the WebAssembly.Module() constructor to create a new WebAssembly module instance.</p><p>Once you have a WebAssembly module instance, you can use it to create an instance of a WebAssembly module using WebAssembly.Instance(), which allows you to call its exported functions and access its memory.</p><h4 id="webassembly-compile" tabindex="-1"><a class="header-anchor" href="#webassembly-compile" aria-hidden="true">#</a> WebAssembly.compile()</h4><p>WebAssembly.compile() is a method in JavaScript that compiles WebAssembly code represented as a Uint8Array object into a WebAssembly.Module object. The Uint8Array object should contain the binary format of the WebAssembly code.</p><p>Here&#39;s an example of using WebAssembly.compile():</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> wasmCode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Uint8Array</span><span class="token punctuation">(</span><span class="token punctuation">[</span> <span class="token comment">/* compiled wasm binary data */</span> <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
WebAssembly<span class="token punctuation">.</span><span class="token function">compile</span><span class="token punctuation">(</span>wasmCode<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">module</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// Use the WebAssembly module here.</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// Handle the error here.</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>In this example, we pass the Uint8Array object containing the binary WebAssembly code to WebAssembly.compile(). The method returns a promise that resolves to a WebAssembly.Module instance representing the compiled WebAssembly code. We can then use this WebAssembly.Module instance to create an instance of the WebAssembly module and use its exported functions.</p><p>It&#39;s worth noting that WebAssembly.compile() is now considered deprecated and it&#39;s recommended to use the WebAssembly.instantiate() method instead, which combines both the compilation and instantiation of a WebAssembly module.</p><h4 id="webassembly-compilestreaming" tabindex="-1"><a class="header-anchor" href="#webassembly-compilestreaming" aria-hidden="true">#</a> WebAssembly.compileStreaming()</h4><p>WebAssembly.compileStreaming() is a method in JavaScript that allows you to asynchronously compile a WebAssembly binary module streamed from a network. This is useful for larger WebAssembly modules, as it can reduce the amount of memory needed to store the binary data in memory before compiling.</p><p>Here&#39;s an example of using WebAssembly.compileStreaming():</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">&#39;example.wasm&#39;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">response</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> WebAssembly<span class="token punctuation">.</span><span class="token function">compileStreaming</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">module</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// Use the WebAssembly module here.</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token parameter">error</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// Handle the error here.</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>In this example, we use the fetch() method to download the WebAssembly binary module from the network. We then pass the response object to WebAssembly.compileStreaming(), which returns a promise that resolves to a WebAssembly.Module instance representing the compiled WebAssembly module. We can then use this WebAssembly.Module instance to create an instance of the WebAssembly module and use its exported functions.</p><p>Note that WebAssembly.compileStreaming() is an asynchronous method and returns a promise. It&#39;s supported in modern web browsers and Node.js. If the method is not supported, you can use the WebAssembly.instantiateStreaming() method as an alternative.</p><h4 id="webassembly-instance" tabindex="-1"><a class="header-anchor" href="#webassembly-instance" aria-hidden="true">#</a> WebAssembly.Instance()</h4><p>WebAssembly.Instance() is a constructor function in JavaScript that creates a new instance of a WebAssembly module. It takes two arguments: a WebAssembly.Module instance, and an optional import object that specifies the imports needed by the WebAssembly module.</p><p>Here&#39;s an example of using WebAssembly.Instance():</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> wasmCode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Uint8Array</span><span class="token punctuation">(</span><span class="token punctuation">[</span> <span class="token comment">/* compiled wasm binary data */</span> <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> wasmModule <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WebAssembly<span class="token punctuation">.</span>Module</span><span class="token punctuation">(</span>wasmCode<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> imports <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token comment">/* import object */</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> wasmInstance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WebAssembly<span class="token punctuation">.</span>Instance</span><span class="token punctuation">(</span>wasmModule<span class="token punctuation">,</span> imports<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>In this example, we first create a Uint8Array instance that contains the compiled WebAssembly binary data. We then create a WebAssembly.Module instance using the WebAssembly.Module() constructor. We also create an import object that specifies the imports needed by the WebAssembly module.</p><p>Finally, we use the WebAssembly.Instance() constructor to create a new instance of the WebAssembly module, passing in the WebAssembly.Module instance and the import object as arguments. The resulting WebAssembly.Instance instance can be used to call the exported functions of the WebAssembly module and access its memory.</p><p>Note that the import object is optional and can be omitted if the WebAssembly module does not have any imports.</p><h4 id="webassembly-instantiate" tabindex="-1"><a class="header-anchor" href="#webassembly-instantiate" aria-hidden="true">#</a> WebAssembly.instantiate()</h4><p>WebAssembly.instantiate() is a method in JavaScript that compiles and instantiates a WebAssembly module in a single step. It takes two arguments: a WebAssembly.Module instance, and an optional import object that specifies the imports needed by the WebAssembly module.</p><p>Here&#39;s an example of using WebAssembly.instantiate():</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> wasmCode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Uint8Array</span><span class="token punctuation">(</span><span class="token punctuation">[</span> <span class="token comment">/* compiled wasm binary data */</span> <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> imports <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token comment">/* import object */</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
WebAssembly<span class="token punctuation">.</span><span class="token function">instantiate</span><span class="token punctuation">(</span>wasmCode<span class="token punctuation">,</span> imports<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">result</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> wasmInstance <span class="token operator">=</span> result<span class="token punctuation">.</span>instance<span class="token punctuation">;</span>
  <span class="token comment">// Use the WebAssembly instance here.</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// Handle the error here.</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>In this example, we first create a Uint8Array instance that contains the compiled WebAssembly binary data. We also create an import object that specifies the imports needed by the WebAssembly module.</p><p>We then use the WebAssembly.instantiate() method to compile and instantiate the WebAssembly module in a single step, passing in the Uint8Array instance and the import object as arguments. The method returns a promise that resolves to an object containing the compiled and instantiated WebAssembly module.</p><p>The WebAssembly.instantiate() method is useful because it combines the compilation and instantiation steps into a single call, making the code more concise. However, it does not provide the flexibility of separately compiling and instantiating the module, which may be necessary for more advanced use cases.</p><h4 id="webassembly-instantiatestreaming" tabindex="-1"><a class="header-anchor" href="#webassembly-instantiatestreaming" aria-hidden="true">#</a> WebAssembly.instantiateStreaming()</h4><p>WebAssembly.instantiateStreaming() is a method in JavaScript that allows you to asynchronously compile and instantiate a WebAssembly binary module streamed from a network. This method is useful for larger WebAssembly modules as it can reduce the amount of memory needed to store the binary data before compiling and instantiating.</p><p>Here&#39;s an example of using WebAssembly.instantiateStreaming():</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">&#39;example.wasm&#39;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">response</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> WebAssembly<span class="token punctuation">.</span><span class="token function">instantiateStreaming</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">result</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> wasmInstance <span class="token operator">=</span> result<span class="token punctuation">.</span>instance<span class="token punctuation">;</span>
  <span class="token comment">// Use the WebAssembly instance here.</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token parameter">error</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// Handle the error here.</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>In this example, we use the fetch() method to download the WebAssembly binary module from the network. We then pass the response object to WebAssembly.instantiateStreaming(), which returns a promise that resolves to an object containing the compiled and instantiated WebAssembly module. We can then use the result.instance property to access the WebAssembly module instance and its exported functions.</p><p>Note that WebAssembly.instantiateStreaming() is an asynchronous method and returns a promise. It&#39;s supported in modern web browsers and Node.js. If the method is not supported, you can use the fetch() and WebAssembly.instantiate() methods as an alternative.</p><h2 id="javascript-call-wasm" tabindex="-1"><a class="header-anchor" href="#javascript-call-wasm" aria-hidden="true">#</a> JavaScript call WASM</h2><h4 id="export-webassembly-functions" tabindex="-1"><a class="header-anchor" href="#export-webassembly-functions" aria-hidden="true">#</a> Export WebAssembly functions</h4><p>To allow JavaScript to access the WebAssembly interface, the first step is to expose the WebAssembly interface. By default, WebAssembly only exposes the main interface, which can be optimized away. For example:</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>When we compile the file using the following command, the add() function will be optimized by the compiler because it has not been declared as an exported function:</p><div class="language-bash" data-ext="sh"><pre class="language-bash"><code>emcc test.c <span class="token parameter variable">-O2</span> <span class="token parameter variable">-o</span> test.js
</code></pre></div><p>The above command is a compilation command, where emcc is the command used for compilation, test.c is the file being compiled. -O2 represents the optimization level for compilation, which has three levels: O1, O2, and O3. The higher the value, the better the optimization and the higher the execution efficiency. -o is used to specify the output file. If -o is followed by test.js, the compiler will output two files: test.js and test.wasm. If it is followed by test.html, the output will be three files: test.html, test.js, and test.wasm.</p><p>In fact, even if the add() function is used by other functions, it will still be optimized by the compiler if it is not declared as an exported function. For example, if we make the following adjustments to test.c:</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">333</span><span class="token punctuation">,</span> <span class="token number">444</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>After recompiling the adjusted test.c, the add() function will still be optimized by the compiler.</p><div class="custom-container tip"><p class="custom-container-title">TIP</p><p>Now we can conclude that the interfaces defined in WebAssembly will always be optimized by the compiler during compilation if they are not specially handled, which will make them unusable for the outer application.</p></div><p>So, how can we expose the interfaces defined in WebAssembly? The Emscripten toolchain provides us with two methods:</p><p>#####Do not export the main function# Method 1: The export interfaces defined in the source code need to be specially marked for identification.</p><p>How to export functions through source code? It&#39;s actually very simple. Just add the keyword <code>EMSCRIPTEN_KEEPALIVE</code> in front of each function to be exported. During compilation, when the compiler detects this keyword in front of a function, it will keep that function.</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;emscripten.h&gt;</span></span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
EMSCRIPTEN_KEEPALIVE <span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>After modifying the code, recompile the test.c file, and you will see that the add() function has indeed been preserved.</p><h6 id="method-2-specify-which-interfaces-to-export-during-compilation" tabindex="-1"><a class="header-anchor" href="#method-2-specify-which-interfaces-to-export-during-compilation" aria-hidden="true">#</a> Method 2: Specify which interfaces to export during compilation.</h6><p>In addition to adding the EMSCRIPTEN_KEEPALIVE keyword in the source code, another way to export functions is to specify which functions to export through compilation options. Suppose we add a new function power() to the test.c file, with the following code:</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">int</span> <span class="token function">power</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> a <span class="token operator">*</span> a<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>To expose the power() function when compiling the WebAssembly module, follow these steps:</p><div class="language-bash" data-ext="sh"><pre class="language-bash"><code>emcc test.c <span class="token parameter variable">-s</span> <span class="token assign-left variable">EXPORTED_FUNCTIONS</span><span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">&#39;_main, _power&#39;</span><span class="token punctuation">]</span> <span class="token parameter variable">-O2</span> <span class="token parameter variable">-o</span> test.js
</code></pre></div><p>Using the above compilation command will expose the main() and power() functions in the test.c file. The EXPORTED_FUNCTIONS parameter specifies which functions to expose. All the functions that need to be exposed are concatenated into a string and enclosed in brackets, which are then assigned to the EXPORTED_FUNCTIONS parameter.</p><h4 id="do-not-export-the-main-function" tabindex="-1"><a class="header-anchor" href="#do-not-export-the-main-function" aria-hidden="true">#</a> Do not export the main function</h4><p>In most cases, the WebAssembly modules we write do not need to expose the main() function. The main() function is more for convenience in testing, so when we officially release a WebAssembly module, we usually remove the main() function.</p><p>Usually, people think of removing the main() function by deleting or commenting it out in the source code, which is certainly feasible. However, the Emscripten compilation tool provides us with a better method. We can add the --no-entry option during compilation to instruct the compiler not to export the main() function. The compilation command is as follows:</p><div class="language-bash" data-ext="sh"><pre class="language-bash"><code>emcc test.c --no-entry <span class="token parameter variable">-s</span> <span class="token assign-left variable">EXPORTED_FUNCTIONS</span><span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">&#39;_add, _power&#39;</span><span class="token punctuation">]</span> <span class="token parameter variable">-O2</span> <span class="token parameter variable">-o</span> test.js
</code></pre></div><h4 id="calling-the-exported-function" tabindex="-1"><a class="header-anchor" href="#calling-the-exported-function" aria-hidden="true">#</a> Calling the exported function</h4><p>Now that we understand how to expose interface functions of WebAssembly, let&#39;s learn how to call these exported functions.</p><p>The WebAssembly glue file provides us with three ways to call exported functions:</p><ol><li>To call the WebAssembly exposed interface directly through the Module object</li><li>To call the exposed interface using the <code>ccall</code> method</li><li>Redefined the exposed interface using <code>cwrap</code></li></ol><h4 id="_1-to-call-the-webassembly-exposed-interface-directly-through-the-module-object" tabindex="-1"><a class="header-anchor" href="#_1-to-call-the-webassembly-exposed-interface-directly-through-the-module-object" aria-hidden="true">#</a> 1. To call the WebAssembly exposed interface directly through the Module object</h4><p>Let&#39;s take a look at how to call exported functions through a Module object, such as calling the add() function we exported earlier. The code is as follows:</p><div class="language-html line-numbers-mode" data-ext="html"><pre class="language-html"><code>...
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
  Module <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token comment">// define Module object</span>
  Module<span class="token punctuation">.</span><span class="token function-variable function">onRuntimeInitialized</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// implement the onRuntimeInitialized method for a Module object</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;add:&quot;</span> <span class="token operator">+</span> Module<span class="token punctuation">.</span><span class="token function">_add</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>test.js<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
...
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>In the above code, an empty Module object is first defined, and then the onRuntimeInitialized() method of the Module object is implemented. This method will be executed after the WebAssembly module is loaded. Next, the WebAssembly glue file (test.js) is imported via the <code>&lt;script&gt;</code> tag, and the other properties of the Module object are further completed in the glue file. Finally, after the initialization of the Module runtime is completed, the onRuntimeInitialized() method is called back.</p><p>The logic implemented in the onRuntimeInitialized() method is very simple. It calls the exported _add() function through the Module object and prints the result to the console.</p><p>From the code, it can be seen that calling exported functions through Module is very simple. However, this method of calling also has a major drawback, which is that functions called in this way can only accept arguments of the Number type.</p><p>If you want to pass non-Number type arguments such as strings or arrays, it becomes very cumbersome and requires the following steps:</p><ul><li>Use Module._malloc() to allocate memory in the heap and obtain the memory address.</li><li>Copy the string/array data to the allocated memory location.</li><li>Pass the allocated memory address as a parameter to the C/C++ function for processing.</li><li>Use Module._free() to release the allocated memory address.</li></ul><p>Is there a simpler way to call the function? Yes, there is. The WebAssembly glue file provides a <code>ccall()</code> method that allows us to directly pass string, array, and other types of arguments, saving us from the tedious work. Now let&#39;s take a look at how to use <code>ccall()</code> to call a WebAssembly function.</p><h4 id="_2-to-call-the-exposed-interface-using-the-ccall-method" tabindex="-1"><a class="header-anchor" href="#_2-to-call-the-exposed-interface-using-the-ccall-method" aria-hidden="true">#</a> 2. To call the exposed interface using the <code>ccall</code> method</h4><p>First, let&#39;s take a look at the basic format of the <code>ccall()</code> function, as shown below:</p><div class="language-javascript" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> result <span class="token operator">=</span> Module<span class="token punctuation">.</span><span class="token function">ccall</span><span class="token punctuation">(</span>func_name<span class="token punctuation">,</span> return_type<span class="token punctuation">,</span> arg_types<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>The first parameter of the ccall() function is the name of the C/C++ function to be called, and note that an underscore should not be added before the function name here. The second parameter is the return type string of the called function. For example, if the return type is string, the value filled in here should be &#39;string&#39;. The third parameter is the parameter list of the called function. If we want to pass in two strings, it should be written as [&#39;string&#39;, &#39;string&#39;]. The last parameter is the actual parameter list. For example, if we want to pass in the parameters &quot;hello&quot; and &quot;world&quot;, it should be written as [&quot;hello&quot;, &quot;world&quot;].</p><p>Let&#39;s take a look at a specific example! First, we add a new function called <code>str_merge()</code> to the previous test.c file. The function&#39;s purpose is to merge two strings and return the merged result to the caller. The code is as follows:</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">// add header file</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string.h&gt;</span></span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">str_merge</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>str1<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>str2<span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">int</span> str1_len <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> str2_len <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

  <span class="token keyword">char</span> <span class="token operator">*</span>buf <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>

  <span class="token keyword">if</span><span class="token punctuation">(</span>str1<span class="token punctuation">)</span> str1_len <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>str1<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// get the length of str1</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>str2<span class="token punctuation">)</span> str2_len <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>str2<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// get the length of str2</span>

  size <span class="token operator">=</span> str1_len <span class="token operator">+</span> str2_len<span class="token punctuation">;</span>  <span class="token comment">// calculate the length of the resulting string after merging</span>
  buf <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// allocate space on the heap</span>
  <span class="token function">memset</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// clear the allocated space</span>

  <span class="token keyword">if</span><span class="token punctuation">(</span>str1_len <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">strncpy</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> str1<span class="token punctuation">,</span> str1_len<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment">// copy str1 to temporary buffer</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>str2_len <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">strncpy</span><span class="token punctuation">(</span>buf <span class="token operator">+</span> str1_len<span class="token punctuation">,</span> str2<span class="token punctuation">,</span> str2_len<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// copy str2 to temporary buffer</span>

  <span class="token keyword">return</span> buf<span class="token punctuation">;</span>  <span class="token comment">// return the merged result</span>
<span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Afterward, modify the test.html file to call the <code>str_merge()</code> method in WebAssembly using the <code>ccall()</code> function, as implemented below:</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token operator">...</span>
Module<span class="token punctuation">.</span><span class="token function-variable function">onRuntimeInitialized</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token operator">...</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;ccall:&quot;</span> <span class="token operator">+</span> <span class="token function">ccall</span><span class="token punctuation">(</span><span class="token string">&quot;str_merge&quot;</span><span class="token punctuation">,</span> <span class="token string">&#39;string&#39;</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">&#39;string&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;string&#39;</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;world&quot;</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token operator">...</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>After modifying the code, recompile the test.c file and expose the str_merge() function. This will allow you to see the output string <code>&quot;ccall:hello world!&quot;</code> in the console.</p><h4 id="_3-redefined-the-exposed-interface-using-cwrap" tabindex="-1"><a class="header-anchor" href="#_3-redefined-the-exposed-interface-using-cwrap" aria-hidden="true">#</a> 3. Redefined the exposed interface using <code>cwrap</code></h4><p>In fact, cwrap() cannot directly call functions exported by WebAssembly. Its function is to redefine the function, hence it is also called a wrapper function. In general, ccall() and cwrap() appear together as a pair.</p><p>What does redefining a function mean? It means to wrap an existing function again, and the wrapped function is more in line with our calling habits. Taking ccall() as an example, although it can call WebAssembly interfaces, its calling method is very strange and different from the way we usually call functions. At this time, we can use cwrap() to rewrap the function into a format that we are familiar with.</p><p>Let&#39;s first take a look at the format of ccwrap(), as shown below:</p><div class="language-javascript" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> func <span class="token operator">=</span> Module<span class="token punctuation">.</span><span class="token function">cwrap</span><span class="token punctuation">(</span>func_name<span class="token punctuation">,</span> return_type<span class="token punctuation">,</span> arg_types<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>The first parameter of the cwrap() function in the above format is the name of the WebAssembly function to be called; the second parameter is the return value type, and the third parameter is the list of parameter types. In fact, these parameters have the same meaning as the parameters in ccall().</p><p>Let&#39;s take the function <code>str_merge()</code> as an example again to see how to redefine the function using cwrap(). This time we need to modify the test.html file, with the following code:</p><div class="language-html line-numbers-mode" data-ext="html"><pre class="language-html"><code>...
Module.onRuntimeInitialized = function() {
  // redefine function
  var c_str_merge = cwrap(&#39;str_merge&#39;, &#39;string&#39;, [&#39;string&#39;, &#39;string&#39;]);
  ...
  // call redefine function
  console.log(&quot;cwrap:&quot; + c_str_merge(&quot;hello&quot;, &quot;world!&quot;));
}
...
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>In the above code, firstly, the function str_merge() is redefined using wrap() function in the onRuntimeInitialized() function. The newly defined function is named c_str_merge(). After that, we can call the str_merge() function in the WebAssembly just like calling a normal function. Doesn&#39;t it make you feel much more comfortable?</p><p>However, one thing to note here is that the cwrap() function is not generated by default in the glue file. If we want to use this function, we need to add the EXPORTED_RUNTIME_METHODS option to the compilation command when compiling the WebAssembly module. The specific command is as follows:</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>emcc test.c --no-entry <span class="token parameter variable">-s</span> <span class="token assign-left variable">EXPORTED_FUNCTIONS</span><span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">&#39;_add, _power, _str-merge&#39;</span><span class="token punctuation">]</span> <span class="token parameter variable">-s</span> <span class="token assign-left variable">EXPORTED_RUNTIME_METHODS</span><span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">&#39;ccall&#39;</span>, <span class="token string">&#39;cwrap&#39;</span><span class="token punctuation">]</span> <span class="token parameter variable">-O2</span> <span class="token parameter variable">-o</span> test.js
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>Through the <code>EXPORTED_RUNTIME_METHODS</code> option, the compiler will output the cwrap() function to the glue file, and then we can use cwrap() to redefine the interface in WebAssembly.</p><h2 id="wasm-call-javascript" tabindex="-1"><a class="header-anchor" href="#wasm-call-javascript" aria-hidden="true">#</a> WASM call JavaScript</h2><p>The WebAssembly engine cannot directly manipulate the DOM tree in the browser. If you want to manipulate the DOM tree, you must use the JavaScript engine. Therefore, when you need to manipulate the DOM tree in WebAssembly, you need to use the JavaScript interface to complete it.</p><p>The Emscripten toolchain provides us with five methods for calling JavaScript interfaces from WebAssembly:</p><ul><li>EM_JS macro</li><li>EM_ASM series macros</li><li>emscripten_run_script series functions</li><li>calling JavaScript functions directly from C/C++</li><li>addFunction function</li></ul><p>Below, we will provide a detailed introduction to each of these methods.</p><h4 id="em-js-macro" tabindex="-1"><a class="header-anchor" href="#em-js-macro" aria-hidden="true">#</a> EM_JS macro</h4><p>With EM_JS macro, you can directly write JavaScript functions in C/C++ code, and the C/C++ code can call it just like calling a C function. This approach is similar to inline assembly language in the C language and is called hybrid programming.</p><p>Let&#39;s take a look at the format of the EM_JS macro. It is shown below:</p><div class="language-bash" data-ext="sh"><pre class="language-bash"><code>EM_JS<span class="token punctuation">(</span>return_type, func_name, args, code<span class="token punctuation">)</span>
</code></pre></div><p>The meanings of each parameter of the EM_JS macro are as follows:</p><ul><li><code>return_type</code>: represents the return type of the function. Note that the type here refers to C/C++ types, such as int, float, etc.</li><li><code>func_name</code>: the name of the function.</li><li><code>args</code>: represents the input parameters of the function, which are also C/C++ types.</li><li><code>code</code>: represents the specific implementation logic of the JavaScript code that you write.</li></ul><p>After understanding the format of the EM_JS macro, let&#39;s take a look at how to define a JavaScript function using it. The code is as follows:</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;emscripten.h&gt;</span>  <span class="token comment">// need add header file</span></span>

<span class="token function">EM_JS</span><span class="token punctuation">(</span><span class="token keyword">int</span> add<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>  <span class="token comment">// define a function through EM_JS macro</span>
  var r <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;a + b&quot;</span> <span class="token operator">+</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// output the calculation results to the browser console</span>
  <span class="token keyword">return</span> r
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> v <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// call a function</span>
  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;get JavaScript function ret val: %d\\n&quot;</span><span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// print the return value</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>In the above code, first a JavaScript function named &quot;add()&quot; is defined using the EM_JS macro, which simply performs addition; after that, the function defined by EM_JS is called in the main() function.</p><p>From this, we can also observe that when using EM_JS to define the &quot;add()&quot; function, its input and return types are both &quot;int&quot;, which are C/C++ types. The implementation of the function, however, is written in JavaScript code, with the most obvious indication being the use of the &quot;console.log&quot; function.</p><div class="custom-container tip"><p class="custom-container-title">TIP</p><p>Based on the above analysis, we can see that when using the EM_JS macro for mixed programming, a function uses both C/C++ and JavaScript syntax. For most developers, this programming approach can be a bad experience and is not easy to maintain.</p></div><h4 id="em-asm-series-macros" tabindex="-1"><a class="header-anchor" href="#em-asm-series-macros" aria-hidden="true">#</a> EM_ASM series macros</h4><p>EM_ASM macro is similar to EM_JS macro and is also a hybrid programming method. However, EM_ASM implements code snippets instead of a complete function. Let&#39;s take a look at its format, as shown below:</p><div class="language-bash" data-ext="sh"><pre class="language-bash"><code>EM_ASM<span class="token punctuation">(</span>code, <span class="token punctuation">[</span>args<span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre></div><p>The meaning of the parameters in the EM_ASM macro are as follows:</p><ul><li>code: the specific implementation logic of the JavaScript code snippet.</li><li>args: the input parameter list. The parameters are optional and can be present or absent.</li></ul><p>After understanding the various parameters of the EM_ASM macro, let&#39;s look at an example. The code is as follows:</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">EM_ASM</span><span class="token punctuation">(</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;hi, this is a test for EM_ASM&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>In the above code, a line of JavaScript code is called through the EM_ASM macro to output the string <code>&quot;hi, this is a test for EM_ASM&quot;</code> to the browser console.</p><p>Certainly, you can also pass some parameters to the code snippet in the EM_ASM macro, as shown below:</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">EM_ASM</span><span class="token punctuation">(</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Hi, &quot;</span> <span class="token operator">+</span> <span class="token function">utf8ToString</span><span class="token punctuation">(</span>$<span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">&quot;How are you!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>From the code, it can be seen that the string &quot;How are you&quot; is passed as a parameter to the EM_ASM macro, and the parameter can be received within EM_ASM by using $0. For EM_ASM, all parameters are received in the order of $0, $1, $2, and so on. In addition, the parameters received by the code segment are usually numerical, such as int, float, etc. If you want to receive a string, you need to use the UTF8ToString() function in the glue file to convert it before you can obtain the passed-in string.</p><p>In the previous example, the EM_ASM macro executed only one line of code. In fact, we can make the EM_ASM macro execute a block of code by enclosing the code in curly braces {}. Here&#39;s an example:</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">EM_ASM</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    var r <span class="token operator">=</span> <span class="token function">UTF8ToString</span><span class="token punctuation">(</span>$<span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> $<span class="token number">1</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token char">&#39;result: &#39;</span> <span class="token operator">+</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">&quot;Hello &quot;</span><span class="token punctuation">,</span> <span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>The logic in {} is very simple. It takes two arguments, a string and an integer, then concatenates them together and finally prints the concatenated result.</p><p>When we write JavaScript code using EM_ASM, it doesn&#39;t have a return value. If you want it to return a result, you can use a variant macro of EM_ASM, such as <code>EM_ASM_INT/EM_ASM_DOUBLE/EM_ASM_PTR</code>, which can return integer/floating point/pointer values. For example:</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> t <span class="token operator">=</span> <span class="token function">EM_ASM_INT</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> r <span class="token operator">=</span> $<span class="token number">0</span> <span class="token operator">+</span> $<span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> r<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;t=$d\\n&quot;</span><span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>The meaning of this code is to add up the incoming parameters and then return the sum to the variable <code>t</code>. As you can see from the code, this is achieved using the variant macro EM_ASM_INT of EM_ASM.</p><h4 id="emscripten-run-script-series-functions" tabindex="-1"><a class="header-anchor" href="#emscripten-run-script-series-functions" aria-hidden="true">#</a> emscripten_run_script series functions</h4><h4 id="calling-javascript-functions-directly-from-c-c" tabindex="-1"><a class="header-anchor" href="#calling-javascript-functions-directly-from-c-c" aria-hidden="true">#</a> calling JavaScript functions directly from C/C++</h4><p>The several methods for accessing JavaScript interface from C/C++ introduced earlier are all hybrid programming methods, which means that JavaScript code is mixed with C/C++ code. This hybrid programming has many drawbacks, the biggest of which is poor code maintainability. After a long time, various problems are inevitable.</p><p>Yes, there is a better way to write C/C++ and JavaScript code separately. The next topic we will introduce is about this method.</p><p>Let&#39;s first take a look at how to implement the C/C++ part. In C/C++, you need to declare and call an external interface, as shown below:</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">extern</span> <span class="token keyword">void</span> <span class="token function">js_func</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// declare an external interface</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token function">js_func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// call an external interface</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>The external interface is declared using the &#39;extern&#39; keyword in the code, which is the JavaScript interface we want to call. Later, in the &#39;main()&#39; function, the interface is called. This completes the C/C++ portion of the code.</p><p>After obtaining the C/C++ code, we can proceed to complete the JavaScript portion. In the JavaScript code, we need to implement the external interface declared in the C/C++ code, as shown below:</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// mylib.js</span>

<span class="token function">mergeInto</span><span class="token punctuation">(</span>LibraryManager<span class="token punctuation">.</span>library<span class="token punctuation">,</span> <span class="token punctuation">{</span>  <span class="token comment">// mergeInto is a function required by the Emscripten toolchain</span>
  <span class="token function-variable function">js_func</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// implement a function</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;hi, js_func&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>In JavaScript code, the function mergeInto() is called. This function is provided by the Emscripten toolchain and it takes two parameters. The first parameter is LibraryManager.library, which is a fixed value and cannot be changed. The second parameter is an object containing the implementations of external interfaces declared in C/C++. It&#39;s worth noting that multiple interface functions can be implemented in the same object, separated by commas. Once the code is written, it can be saved in a separate .js file, such as mylib.js.</p><p>As this is just an example, the implementation of the js_func() function is very simple, and it only uses the console.log() function to output a string of characters.</p><p>Through the above steps, we have implemented all the code required for calling JavaScript interfaces from C/C++. Now the C/C++ code and JavaScript code are stored in different files (test.c and mylib.js, respectively), achieving the goal of separating C/C++ and JavaScript code.</p><p>Next, we need to compile the C/C++ and JavaScript code using the following command with the Emscripten toolchain:</p><div class="language-bash" data-ext="sh"><pre class="language-bash"><code>emcc test.c --js-library mylib.js <span class="token parameter variable">-s</span> <span class="token assign-left variable">EXPORTED_FUNCTIONS</span><span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">&#39;_power, _main&#39;</span><span class="token punctuation">]</span> <span class="token parameter variable">-O2</span> <span class="token parameter variable">-o</span> test.js
</code></pre></div><p>In this command, there is a new option called &quot;--js-library&quot;, which tells the Emscripten toolchain that the external interfaces used in C/C++ are defined in the mylib.js file. You need to call the mergeInto() function in that file to copy the implemented JavaScript code to the glue file, so that C/C++ can then invoke the JavaScript interface.</p><p>The example above is a function with no parameters and no return values. If you want to modify it to a function with parameters and return values, it&#39;s also straightforward. First, modify the C/C++ code:</p><div class="language-c" data-ext="c"><pre class="language-c"><code><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">extern</span> <span class="token keyword">int</span> <span class="token function">js_func</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre></div><p>Next, modify the JavaScript code as follows:</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token function">mergeInto</span><span class="token punctuation">(</span>LibraryManager<span class="token punctuation">.</span>library<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">js_func</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>With the above modifications, we can now pass the integers a and b as parameters to the js_func() function and get the function&#39;s return value.</p><p>If you check the compiled glue file and wasm file, the use of calling JavaScript functions by C/C++ is provided by the callback mechanism offered by WebAssembly, as shown in the following figure:</p><p><img src="http://wechatapppro-1252524126.cdn.xiaoeknow.com/appmi4bxt8x7465/image/ueditor/69825800_1661256767.cn/mmbiz_png/czekj44ymybgqd1u7wekv3wmrodjzm8zicncfzllqiaicsrmhmviglmywpia0ibwhrdhsczganiayria1zinssyuzjpg/640?imageView2/2/q/80|imageMogr2/ignore-error/1" alt=""></p><p>When loading the WebAssembly module in the glue file, an importObject object needs to be passed in, which contains all the functions that WebAssembly needs to import. The js_func() function in the previous example is one of the functions that needs to be imported, so when importing WebAssembly, a connection is established between the js_func function and C/C++. This way, when js_func() is called in the main() function, it will find the specific JavaScript implementation from the importObject object and call that implementation to complete the call from C/C++ to JavaScript function.</p><h4 id="addfunction-function" tabindex="-1"><a class="header-anchor" href="#addfunction-function" aria-hidden="true">#</a> addFunction function</h4><p>The Emscripten toolchain provides the addFunction() function for JavaScript, which is used to pass the address of a defined JavaScript function to C/C++ code. The C/C++ code then uses this function address to access the JavaScript function.</p><p>Let&#39;s take a look at the specific steps. The first step is to implement the JavaScript interface and call addFunction() to pass the function address to the C/C++ code. The code is as follows:</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// test.html</span>
<span class="token operator">...</span>
Module<span class="token punctuation">.</span><span class="token function-variable function">onRuntimeInitialized</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// define a JavaScript interface</span>
  <span class="token keyword">function</span> <span class="token function">testAddFunc</span><span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;hi, addFunction, &quot;</span> <span class="token operator">+</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> a<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// assign the defined interface to the addFunction() function and obtain the function pointer</span>
  <span class="token keyword">var</span> func_ptr <span class="token operator">=</span> <span class="token function">addFunction</span><span class="token punctuation">(</span>testAddFunc<span class="token punctuation">,</span> <span class="token string">&quot;ii&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// call the C/C++ wrapper function and pass the function pointer to the C/C++ code</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;testAddFunc: &quot;</span> <span class="token operator">+</span> Module<span class="token punctuation">.</span><span class="token function">_runFuncByPtr</span><span class="token punctuation">(</span>func_ptr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token operator">...</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>In the above code, a interface function testAddFunc() is defined, which simply prints a log. Then the addFunction() function is called to obtain the function pointer of testAddFunc(). It should be noted that the second parameter of the addFunction() function is a signature string, which represents the input and return types of the function, and each type is represented by a letter, such as &#39;int&#39; is represented by &#39;i&#39;, and &#39;void&#39; is represented by &#39;v&#39;. Finally, the wrapper function runFuncByPtr() is called to pass the function pointer to the C/C++ layer. This is the logic of the JavaScript code. After the JavaScript code is written, we can proceed to implement the C/C++ code, as follows:</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">int</span> <span class="token function">external_method</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// define a function type</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token comment">// implement the wrapper function</span>
<span class="token keyword">int</span> <span class="token function">runFuncByPtr</span><span class="token punctuation">(</span><span class="token keyword">int</span> ptr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>external_method<span class="token operator">*</span><span class="token punctuation">)</span>ptr<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">88</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>The meaning of signature: &#39;v&#39;: void type &#39;i&#39;: 32-bit integer type &#39;j&#39;: 64-bit integer type (currently does not exist in JavaScript) &#39;f&#39;: 32-bit float type &#39;d&#39;: 64-bit float type</p><p>The C/C++ part is relatively simple. First, it defines a function type through typedef. Then, in the wrapper function runFuncByPtr(), it casts the passed-in pointer to the defined function address and calls the function to obtain the result.</p><p>After the JavaScript and C/C++ code are written, the following compilation command can be used to generate the glue file and WebAssembly module:</p><div class="language-dash" data-ext="dash"><pre class="language-dash"><code>emcc mytest.c -s EXPORTED_FUNCTION=_runFuncByPtr,_power -s EXPORTED_RUNTIME_METHODS=addFunction -s ALLOW_TABLE_GROWTH -O2 -o test.js
</code></pre></div><p>You may already understand most of the parameters in this command, but there are two options that need to be emphasized:</p><ul><li><p>The EXPORTED_RUNTIME_METHODS option with the value addFunction is used to enable additional runtime methods in the glue code. As mentioned earlier when explaining the cwrap() function, if this option is not specified, the glue code will not include the cwrap() function and other related runtime methods like addFunction(). Therefore, we need to include this option in the compilation command to generate the addFunction() function in the glue code.</p></li><li><p>The ALLOW_TABLE_GROWTH option needs to be included during compilation, because addFunction() automatically increases the size of the table as needed. If this option is not specified during compilation, an error will occur.</p></li></ul><h2 id="wasm-memory-management" tabindex="-1"><a class="header-anchor" href="#wasm-memory-management" aria-hidden="true">#</a> WASM Memory Management</h2>`,241),i=[o];function p(c,l){return s(),a("div",null,i)}const u=n(t,[["render",p],["__file","webAssembly.html.vue"]]);export{u as default};
